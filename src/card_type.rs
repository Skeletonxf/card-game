use crate::cards::Cards;
use crate::state::{Action, ActivationStatus, GameState, CardInstance, CardStatus};

use std::fmt;
use std::fmt::Debug;

use serde::{Deserialize, Serialize};

/// A unique identifier for a card type. Not part of the files, autogenerated at loading time.
#[derive(Copy, Clone, Default, Debug, Eq, PartialEq, Deserialize, Serialize)]
pub struct CardTypeIdentifier(pub u32);

/// A card type is like the class for cards. Cards are instances of a single CardType
#[derive(Debug, Deserialize, Serialize)]
pub struct CardType {
    #[serde(skip_deserializing)]
    pub id: CardTypeIdentifier,
    pub name: String,
    #[serde(default)]
    pub effects: Vec<Box<dyn CardEffect>>,
    pub defense: u32,
    pub attack: u32,
}

#[typetag::serde(tag = "type")]
pub trait CardEffect: Send + Sync + fmt::Debug {
    /// How can this card type effect out of the card pool activate in this game state for this card instance in the game state?
    fn can_activate(&self, card_pool: &Cards, card_type: &CardType, game_state: &GameState, instance: CardInstance) -> ActivationStatus;

    /// Try to activate this card type effect out of the card pool in this game state for this card instance in the game state
    fn activate(&self, card_pool: &Cards, card_type: &CardType, game_state: &mut GameState, instance: CardInstance);
}

#[derive(Debug, Deserialize, Serialize)]
pub struct OnSummon {
    pub mandatory: bool,
    pub trigger: Box<dyn EffectTrigger>,
}

#[typetag::serde]
impl CardEffect for OnSummon {
    fn can_activate(&self, _card_pool: &Cards, card_type: &CardType, game_state: &GameState, instance: CardInstance) -> ActivationStatus {
        if game_state.field.values()
            .any(|card|
                card.instance == instance
                && card.instance_of(card_type)
                && card.state == CardStatus::Summoned
            )
        {
            if self.mandatory { ActivationStatus::Mandatory } else { ActivationStatus::Can }
        } else {
            ActivationStatus::Cannot
        }
    }

    fn activate(&self, card_pool: &Cards, card_type: &CardType, game_state: &mut GameState, instance: CardInstance) {
        if self.can_activate(card_pool, card_type, game_state, instance).possible() {
            self.trigger.activation(card_pool, card_type, game_state, instance);
            self.trigger.resolution(card_pool, card_type, game_state, instance);
        }
    }
}

#[typetag::serde(tag = "type")]
pub trait EffectTrigger: Send + Sync + fmt::Debug {
    fn activation(&self, card_pool: &Cards, card_type: &CardType, game_state: &mut GameState, instance: CardInstance);
    fn resolution(&self, card_pool: &Cards, card_type: &CardType, game_state: &mut GameState, instance: CardInstance);
}

#[derive(Debug, Deserialize, Serialize)]
pub struct DestroySelfUnless {
    pub condition: Box<dyn Condition>,
}

#[typetag::serde]
impl EffectTrigger for DestroySelfUnless {
    fn activation(&self, card_pool: &Cards, card_type: &CardType, game_state: &mut GameState, instance: CardInstance) {
        if !self.condition.met(card_pool, card_type, game_state, instance) {
            // swallow error, we don't care if the instance is actually on the field, just that
            // it gets destroyed if it is
            let _ = game_state.take_action(card_pool, Action::DestroyOnField(instance));
        }
    }
    fn resolution(&self, _card_pool: &Cards, _card_type: &CardType, _game_state: &mut GameState, _instance: CardInstance) {
        // No resolution effect
    }
}

#[typetag::serde(tag = "type")]
pub trait Condition: Send + Sync + fmt::Debug {
    /// Is this card type out of the card pool in this game state for for this card instance able to meet its condition?
    fn met(&self, card_pool: &Cards, card_type: &CardType, game_state: &GameState, instance: CardInstance) -> bool;
}

#[derive(Debug, Deserialize, Serialize)]
pub struct NamedCardOnField {
    pub name: String,
}

#[typetag::serde]
impl Condition for NamedCardOnField {
    fn met(&self, card_pool: &Cards, _card_type: &CardType, game_state: &GameState, _instance: CardInstance) -> bool {
        game_state.field.values().any(|card| card.has_name(card_pool, &self.name))
    }
}
